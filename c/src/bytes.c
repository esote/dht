#include <stdint.h>
#include <string.h>
#include "bytes.h"

static size_t leading_zeros(uint8_t b);

static uint16_t
bswap_16(uint16_t x)
{
	return (uint16_t)(x<<8 | x>>8);
}

static uint32_t
bswap_32(uint32_t x)
{
	return x>>24 | ((x>>8)&0xff00) | ((x<<8)&0xff0000) | x<<24;
}

static uint64_t
bswap_64(uint64_t x)
{
	return ((uint64_t)bswap_32((uint32_t)x))<<32 | bswap_32((uint32_t)(x>>32));
}

static uint16_t
hton_16b(uint16_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_16(x);
	}
	return x;
}

static uint16_t
ntoh_16b(uint16_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_16(x);
	}
	return x;
}

static uint32_t
hton_32b(uint32_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_32(x);
	}
	return x;
}

static uint32_t
ntoh_32b(uint32_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_32(x);
	}
	return x;
}

static uint64_t
hton_64b(uint64_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_64(x);
	}
	return x;
}

static uint64_t
ntoh_64b(uint64_t x)
{
	union { int i; char c; } u = { 1 };
	if (u.c == 1) {
		return bswap_64(x);
	}
	return x;
}

void
hton_16(void *dst, uint16_t x)
{
	union { uint16_t i; uint8_t b[2]; } u;
	u.i = hton_16b(x);
	(void)memcpy(dst, u.b, 2);
}

uint16_t
ntoh_16(const void *src)
{
	union { uint8_t b[2]; uint16_t i; } u;
	(void)memcpy(u.b, src, 2);
	return ntoh_16b(u.i);
}

void
hton_32(void *dst, uint32_t x)
{
	union { uint32_t i; uint8_t b[4]; } u;
	u.i = hton_32b(x);
	(void)memcpy(dst, u.b, 4);
}

uint32_t
ntoh_32(const void *src)
{
	union { uint8_t b[4]; uint32_t i; } u;
	(void)memcpy(u.b, src, 4);
	return ntoh_32b(u.i);
}

void
hton_64(void *dst, uint64_t x)
{
	union { uint64_t i; uint8_t b[8]; } u;
	u.i = hton_64b(x);
	(void)memcpy(dst, u.b, 8);
}

uint64_t
ntoh_64(const void *src)
{
	union { uint8_t b[8]; uint64_t i; } u;
	(void)memcpy(u.b, src, 8);
	return ntoh_64b(u.i);
}

size_t
lcp(const uint8_t *x, const uint8_t *y, size_t len)
{
	size_t i;
	uint8_t b;
	for (i = 0; i < len; i++) {
		if ((b = x[i] ^ y[i]) != 0) {
			return i*8 + leading_zeros(b);
		}
	}
	return len*8;
}

static uint8_t len8tab[256] = {
	0x00, 0x01, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
	0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
};

static size_t
leading_zeros(uint8_t b)
{
	return 8 - len8tab[b];
}
